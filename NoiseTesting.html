<!DOCTYPE html>
<html lang="en">
	<head>
		<title>b-spline	</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #1f1f1f;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #0080ff;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script src="./three.js/examples/js/Detector.js"></script>
		<script src="./SimplexNoise.js"></script>
		<script src="./PerlinSimplex.js"></script>
		<script src="./VertexColorHeight.js"></script>
		<script src="./three.js/build/three.min.js"></script>
		<script src="./three.js/examples/js/libs/stats.min.js"></script>
		<script src="./three.js/examples/js/libs/tween.min.js"></script>
		
		<!-- Shaders -->
		<script type="x-shader/x-vertex" id="vertexshader">

			// switch on high precision floats
			
			//in vec4 position;
			//in vec4 color;
			varying vec4 vColor;
		 
		    void main() {
		        vec3 newPosition = position +  vec3(0,vColor.r*100.0,0);
		        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
		    }

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
	 
	 		varying lowp vec4 vColor;
	        void main() {
	            gl_FragColor = vColor;
	        }

		</script>

		<!-- End Shaders -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, scene, renderer;
			var mesh;
			var projector;
			var mouseVector;

			var text = [];

			var x,y;

			var terrainElements = [];

			var simpleLine;
			var objectSelect = false;
			var selectedObject;
			var indexPoint = 0;

			//Mouse variables
			var lastX,lastY;
			var divX,divY;
			var wasClicked = false;
			//
			var uniforms = {
				 time: { type: "f", value: 0 },
				 resolution: { type: "v2", value: new THREE.Vector2 },
				 texture: { type: "t", value: THREE.ImageUtils.loadTexture('./b.png') }
				};


			var sizeOfCamera;
			var clock = 0;
			init();
			animate();

			function init() {

				initPerm();
				container = document.getElementById( 'container' );

				sizeOfCamera = 50;

				camera = new THREE.PerspectiveCamera( sizeOfCamera, window.innerWidth / window.innerHeight, 1, 500 );
				camera.position.z = 100;
				camera.lookAt(new THREE.Vector3(0, 0, 0));

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				projector = new THREE.Projector();
				mouseVector = new THREE.Vector3();


				createText(100,100,50,10);



				container.appendChild( renderer.domElement );


				var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 ); 
				directionalLight.position.set( 300, 300, -300 ); 
				scene.add( directionalLight );
				createPlane(new THREE.Vector3(0,0,0),70,0xffffff,100);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );

			}
			function createText(sizeX,sizeY,posX,posY)
			{
				var text2 = document.createElement('div');
				text2.style.position = 'absolute';
				text2.style.width = sizeX;
				text2.style.height = sizeY;
				text2.innerHTML = "hi there!";
				text2.style.top = posX + 'px';
				text2.style.left = posY + 'px';
				document.body.appendChild(text2);

				text.push(text2);
			}
			function createPlane(vecPos,size,col,sizeOfSub)
			{
				var mainGeometry = new THREE.PlaneGeometry( size, size, sizeOfSub,sizeOfSub );
			
				var color, point, face, numberOfSides, vertexIndex;
				mainGeometry.computeBoundingBox();


				var shaderMaterial =
				  new THREE.ShaderMaterial({
				    vertexShader:   $('#vertexshader').text(),
					fragmentShader: $('#fragmentshader').text()
				  });

				 

				var itemMaterial = new THREE.ShaderMaterial({
				    uniforms: uniforms,
				    vertexShader: document.getElementById('vertexshader').innerHTML,
				    fragmentShader: document.getElementById('fragmentshader').innerHTML
				});



				var faceIndices = [ 'a', 'b', 'c', 'd' ];
				

				var NoiseObject = PerlinSimplex;
				NoiseObject.noiseDetail(3,1);

				for ( var i = 0; i < mainGeometry.vertices.length; i++ ) 
				{
				    point = mainGeometry.vertices[ i ];
					text[0].innerHTML = point.x;
					var valueNoise = NoiseObject.noise(point.x/size*2,point.y/size*2,0,0);
				    color = new THREE.Color( 0xffffff );


				    color.setRGB( valueNoise, valueNoise, valueNoise );
				    mainGeometry.colors[i] = color;
				}


				for ( var i = 0; i < mainGeometry.faces.length; i++ ) 
				{
				    face = mainGeometry.faces[ i ];
				    numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
				    for( var j = 0; j < numberOfSides; j++ ) 
				    {
				        vertexIndex = face[ faceIndices[ j ] ];
				        face.vertexColors[ j ] = mainGeometry.colors[ vertexIndex ];
				    }
				}


				var plane = new THREE.Mesh(mainGeometry, itemMaterial);
				plane.position = vecPos; 
				plane.geometry.materialsNeedUpdate = true;

				scene.add( plane );

				terrainElements.push(plane);
				}

			function onDocumentMouseDown(event)
		    {
				event.preventDefault();
				wasClicked = true;

				lastY = event.clientY;
				lastX = event.clientX;
				
			}
			function onDocumentMouseMove(event)
			{
				event.preventDefault();
				if(wasClicked)
				{
					divX = event.clientX - lastX;
					divY = event.clientY - lastY;
					terrainElements[0].rotation.x+=divY/sizeOfCamera;
					terrainElements[0].rotation.y+=divX/sizeOfCamera;
				}
				lastY = event.clientY;
				lastX = event.clientX;

			}
			function onDocumentMouseUp(event)
			{
				event.preventDefault();
				wasClicked = false;
			}
			
			function onWindowResize() 
			{
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate()
			{
				requestAnimationFrame( animate );

				stats.update();
//
				render();
			}
			function render()
		    {
				renderer.render( scene, camera );
				clock+=1;
				uniforms.time.value += 0.1;
			}

		</script>

	</body>
</html>
