<!DOCTYPE html>
<html lang="en">
	<head>
		<title>b-spline	</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #1f1f1f;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #0080ff;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script src="./three.js/examples/js/Detector.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script src="./SimplexNoise.js"></script>
		<script src="./PerlinSimplex.js"></script>
		<script src="./VertexColorHeight.js"></script>
		<script src="./THREEx.KeyboardState.js"></script>
		<script src="./three.js/build/three.min.js"></script>
		<script src="./three.js/examples/js/libs/stats.min.js"></script>
		<script src="./three.js/examples/js/libs/tween.min.js"></script>
		<script type="text/javascript" src="dat.gui.min.js"></script>
		
		<!-- Shaders -->
		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float displacement;
			attribute vec3 colors;
			varying lowp vec4 vColor;
			varying vec3 passNormal;
		 
		    void main() {
		    	passNormal = normalize(normal);
		        vec3 newPosition = position +  vec3(0,0,displacement*0.0);
		        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
		        vColor = vec4(colors,1);
		    }

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
	 		
			varying lowp vec4 vColor;
			varying vec3 passNormal;
			uniform vec3 mainLight;
			uniform vec3 lightColor;

	        void main() {
	            vec3 light = mainLight;
				// ensure it's normalized
				light = normalize(light);
				float dProd = max(0.0, dot(passNormal, light));
				//feed into our frag colour
				gl_FragColor = vec4(dProd*lightColor.x, dProd*lightColor.y, dProd*lightColor.z, 1.0);
		        }

		</script>

		<!-- End Shaders -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var GuiVarHolder = null;

			var container, stats;
			var camera, scene, renderer;
			var mesh;
			var projector;
			var mouseVector;

			var text = [];
			var positionTransformVector;
			var noiseValues = [];

			var x,y;

			var terrainElements = [];

			var keyboardInteraction;

			var simpleLine;
			var objectSelect = false;
			var selectedObject;
			var indexPoint = 0;

			//Mouse variables
			var lastX,lastY;
			var divX,divY;
			var wasClicked = false;
			var firstInteraction = false
			var cameraEnabled = false;
			//
			var noiseAttributes = {
				displacement: {
				    type: 'f', // a float
				    value: [] // an empty array
				},
				colors: { 
					type: "c", 
					value: [] }
			}
			var uniforms = {
				dis: {
				    type: 'f', // a float
				    value: 0 
			  },
			  	mainLight: {
			  		type: "v3",
			  		value: new THREE.Vector3( 0, 1, 1 )
			  },
			  	lightColor: {
			  		type: "v3",
			  		value: new THREE.Vector3 (1, 1, 1)
			  	}
			};

			var sizeOfCamera;
			var clock = 0;
			init();
			animate();

			function init() {

				initPerm();
				container = document.getElementById( 'container' );
				keyboardInteraction = new THREEx.KeyboardState();

				sizeOfCamera = 50;

				camera = new THREE.PerspectiveCamera( sizeOfCamera, window.innerWidth / window.innerHeight, 1, 500 );
				camera.position.z = 100;
				camera.lookAt(new THREE.Vector3(0, 0, 0));

				scene = new THREE.Scene();
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColorHex( 0x0f0f0f, 1 );

				projector = new THREE.Projector();
				mouseVector = new THREE.Vector3();

//				createText(100,100,50,10);

				uniforms.mainLight.value = new THREE.Vector3(0.2,1,1);

				var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
				directionalLight.position.set( 0, 1, 0 ).normalize(); 
				scene.add( directionalLight );

				container.appendChild( renderer.domElement );

				createPlane(new THREE.Vector3(0,-15,0),70,0xffffff,150);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );

			}

			var FizzyText = function() {
			  this.message = 'dat.gui';
			  this.cameraEnabled = false;
			  this.rotationEnabled = false;
			  this.keyboardEnabled = false;
			  this.lightX = 0.02;
			  this.lightY = 0.02;
			  this.lightZ = 0.02;

			  this.lightCR = 1;
			  this.lightCG = 1;
			  this.lightCB = 1;

			  this.setColor = function()
			  {
			  	uniforms.lightColor = new THREE.Vector3(this.lightCR,this.lightCG,this.lightCB);
			  }
			  //this.explode = function() { ... };
			  // Define render logic ...
			};

			window.onload = function() {
			  GuiVarHolder = new FizzyText();
			  var gui = new dat.GUI();

			  var f1 = gui.addFolder('ControlsEnabled');

			  f1.add(GuiVarHolder, 'cameraEnabled');
			  f1.add(GuiVarHolder, 'rotationEnabled');
			  f1.add(GuiVarHolder, 'keyboardEnabled');

			  var f2 = gui.addFolder('MainLight');

			  f2.add(GuiVarHolder, 'lightX',0,0.06);
			  f2.add(GuiVarHolder, 'lightY',0,0.06);
			  f2.add(GuiVarHolder, 'lightZ',0,0.06);

			  var f3 = gui.addFolder('MainLight Color');

			  f3.add(GuiVarHolder, 'lightCR',0,1);
			  f3.add(GuiVarHolder, 'lightCG',0,1);
			  f3.add(GuiVarHolder, 'lightCB',0,1);
			  f3.add(GuiVarHolder, 'setColor');
			 //gui.add(text, 'explode');
			};


			function createText(sizeX,sizeY,posX,posY)
			{
				var text2 = document.createElement('div');
				text2.style.position = 'absolute';
				text2.style.width = sizeX;
				text2.style.height = sizeY;
				text2.innerHTML = "hi there!";
				text2.style.top = posX + 'px';
				text2.style.left = posY + 'px';
				document.body.appendChild(text2);

				text.push(text2);
			}
			function createPlane(vecPos,size,col,sizeOfSub)
			{
				var mainGeometry = new THREE.PlaneGeometry( size, size, sizeOfSub,sizeOfSub );
			
				var color, point, face, numberOfSides, vertexIndex;
				mainGeometry.computeBoundingBox();


				var faceIndices = [ 'a', 'b', 'c', 'd' ];
				

				var NoiseObject = PerlinSimplex;
				NoiseObject.noiseDetail(3,0.5);
				var values = noiseAttributes.displacement.value;
				var valuesColors = noiseAttributes.colors.value;
				for ( var i = 0; i < mainGeometry.vertices.length; i++ ) 
				{
				    point = mainGeometry.vertices[ i ];
					var valueNoise = NoiseObject.noise(point.x/size*1,point.y/size*1,0,0);

				    color = new THREE.Color( 0xffffff );  
				    color.setRGB( valueNoise, valueNoise, valueNoise );
					mainGeometry.vertices[ i ] = new THREE.Vector3(point.x,point.y,point.z + valueNoise*45);

				    noiseValues.push(valueNoise);
				    values.push(valueNoise);
				    valuesColors.push(color);
				}

				var basicDisplacmentMat = getMaterialDis();


				for ( var i = 0; i < mainGeometry.faces.length; i++ ) 
				{
				    face = mainGeometry.faces[ i ];

				    face.vertexNormals[0] = null;
				    face.vertexNormals[1] = null;
				    face.vertexNormals[2] = null;
				}


				for ( var i = 0; i < mainGeometry.faces.length; i++ ) 
				{
				    face = mainGeometry.faces[ i ];

				    var normalVec = calculateNormals(
				    	mainGeometry.vertices[face.a], 
				    	mainGeometry.vertices[face.b], 
				    	mainGeometry.vertices[face.c]);	

				    for(var j =0;j< 3;j++)
				    {
				    	if(face.vertexNormals[j] == null)
							face.vertexNormals[j] = normalVec;
						else
						{
							face.vertexNormals[j] += normalVec;
							console.log(face.vertexNormals[j]);
						}

						face.vertexNormals[j].normalize();

					}

				}
				var plane = new THREE.Mesh(mainGeometry, basicDisplacmentMat);
				plane.position = vecPos; 
				plane.geometry.materialsNeedUpdate = true;

				scene.add( plane );

				terrainElements.push(plane);	
			}	
			
			function getMaterialDis()
			{
				var mat =  new THREE.ShaderMaterial({
					attributes: noiseAttributes,
					uniforms:       uniforms,
				    vertexShader: document.getElementById('vertexshader').innerHTML,
				    fragmentShader: document.getElementById('fragmentshader').innerHTML
				});
				mat.wireframe = false;
				//mat.lights = true;
				//mat.shading = THREE.FlatShading;
				return mat;
			}
			function getMaterialLamb()
			{
				var mat =  new THREE.MeshPhongMaterial({
        		color: 'white' 
      			});
				return mat;
			}

			function onDocumentMouseDown(event)
		    {
				event.preventDefault();
				wasClicked = true;
				firstInteraction = true;
				lastY = event.clientY;
				lastX = event.clientX;
				
			}
			function onDocumentMouseMove(event)
			{
				event.preventDefault();

					divX = event.clientX - lastX;
					divY = event.clientY - lastY;

				if(wasClicked && GuiVarHolder.rotationEnabled)
				{	
					terrainElements[0].rotation.x+=divY/sizeOfCamera;
					terrainElements[0].rotation.y+=divX/sizeOfCamera;
	
				}
				else if(firstInteraction)
				{
					setCameraRotation(divX,divY);
				}
				lastY = event.clientY;
				lastX = event.clientX;


			}

			function setCameraRotation(divx,divY)
			{
				if(!GuiVarHolder.cameraEnabled)
					return;

				camera.rotation.y-= 0.1*divX/sizeOfCamera;
				camera.rotation.x-= 0.1*divY/sizeOfCamera;

				var x = Math.sin((camera.rotation.x*Math.PI)/180.0);
				var y = Math.sin((camera.rotation.y*Math.PI)/180.0);
				var z = Math.sin((camera.rotation.z*Math.PI)/180.0);
				var mulFactor =  1.0/(x + y + z);


				positionTransformVector = new THREE.Vector3(x*mulFactor,y*mulFactor,z*mulFactor);
				positionTransformVector.normalize();
			}
			function keyboardInfo()
			{
				if(GuiVarHolder!=null &&!GuiVarHolder.keyboardEnabled)
					return;
				if(keyboardInteraction.pressed("w"))
				{	
					camera.position.z -= positionTransformVector.x;
				}
				if(keyboardInteraction.pressed("s"))
				{
					camera.position.x -= 1;
				}
				if(keyboardInteraction.pressed("a"))
				{
					camera.position.z += 1;
				}
				if(keyboardInteraction.pressed("d"))
				{
					camera.position.z -= 1;
				}
			}


			function onDocumentMouseUp(event)
			{
				event.preventDefault();
				wasClicked = false;
			}
			
			function onWindowResize() 
			{
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;


				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate()
			{
				requestAnimationFrame( animate );
				if(GuiVarHolder != null)
				{
				uniforms.mainLight.value = new THREE.Vector3(Math.cos(clock*GuiVarHolder.lightX),Math.sin(clock*GuiVarHolder.lightY),Math.cos(clock*GuiVarHolder.lightZ));
				}
				else
				{
					uniforms.mainLight.value = new THREE.Vector3(1,1,1);
				}

				stats.update();
				render();
			}
			function render()
		    {
				renderer.render( scene, camera );
				keyboardInfo();
				clock+=1;
			}

			

			function calculateNormals( a, b, c)
			{
				var ab = new THREE.Vector3(b.x - a.x, b.y - a.y, b.z - a.z);
				var ac = new THREE.Vector3(c.x - a.x, c.y - a.y, c.z - a.z);

				var i = ab.y*ac.z - ab.z*ac.y;
				var j = ab.x*ac.z - ab.z*ac.x;
				var k = ab.x*ac.y - ab.y*ac.x;

				return new THREE.Vector3(i,j,k);
			}
		</script>

	</body>
</html>
